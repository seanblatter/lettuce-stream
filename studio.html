<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Studio Preview - Lettuce Stream</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Space+Grotesk:wght@400;500;600;700&family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        :root {
            color-scheme: light dark;
            --studio-bg: #f4f5fb;
            --studio-panel: #ffffff;
            --studio-accent: #f5d547;
            --studio-accent-soft: rgba(245, 213, 71, 0.2);
            --studio-border: rgba(15, 23, 42, 0.08);
            --studio-text: #0f172a;
            --studio-muted: rgba(15, 23, 42, 0.66);
            --studio-danger: #ff5c5c;
            --studio-shadow: rgba(15, 23, 42, 0.08);
            --studio-pill-bg: rgba(15, 23, 42, 0.06);
            --studio-toast-bg: rgba(15, 23, 42, 0.9);
            --studio-toast-border: rgba(15, 23, 42, 0.2);
        }
        body[data-theme="dark"] {
            --studio-bg: #040916;
            --studio-panel: #0f1c33;
            --studio-border: rgba(255, 255, 255, 0.08);
            --studio-text: #f7fafc;
            --studio-muted: rgba(247, 250, 252, 0.7);
            --studio-shadow: rgba(0, 0, 0, 0.4);
            --studio-pill-bg: rgba(255, 255, 255, 0.08);
            --studio-toast-bg: rgba(6, 12, 24, 0.92);
            --studio-toast-border: rgba(255, 255, 255, 0.12);
        }
        * {
            box-sizing: border-box;
        }
        body {
            margin: 0;
            font-family: 'Inter', 'Space Grotesk', sans-serif;
            background: var(--studio-bg);
            color: var(--studio-text);
            min-height: 100vh;
            transition: background 0.3s ease, color 0.3s ease;
        }
        .studio-shell {
            display: flex;
            flex-direction: column;
            min-height: 100vh;
            padding: 32px;
            gap: 24px;
        }
        .studio-topbar {
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: var(--studio-panel);
            border: 1px solid var(--studio-border);
            border-radius: 20px;
            padding: 20px 28px;
            box-shadow: 0 20px 60px var(--studio-shadow);
            backdrop-filter: blur(20px);
        }
        .studio-title {
            display: flex;
            align-items: center;
            gap: 16px;
        }
        .studio-back {
            border: none;
            background: transparent;
            font-size: 1.2rem;
            cursor: pointer;
            color: var(--studio-text);
            padding: 4px 0;
        }
        .studio-topbar h1,
        .studio-stream-title {
            margin: 0;
            font-size: 1.6rem;
            letter-spacing: -0.02em;
        }
        .studio-title-text {
            display: inline-flex;
            align-items: center;
            min-width: 120px;
            border-bottom: 1px dashed transparent;
            cursor: text;
        }
        .studio-title-text[data-editing="true"] {
            border-bottom-color: var(--studio-border);
        }
        .studio-title-text:focus {
            outline: none;
            border-bottom-color: var(--studio-accent);
        }
        .studio-topbar p {
            margin: 4px 0 0;
            color: var(--studio-muted);
            font-size: 0.95rem;
        }
        .topbar-actions {
            display: flex;
            gap: 12px;
            align-items: center;
        }
        .studio-btn {
            border: 1px solid transparent;
            border-radius: 999px;
            padding: 10px 18px;
            font-size: 0.95rem;
            font-weight: 600;
            cursor: pointer;
            background: rgba(15, 23, 42, 0.05);
            color: var(--studio-text);
            transition: transform 0.15s ease, background 0.15s ease, color 0.15s ease;
        }
        .studio-btn:hover {
            transform: translateY(-1px);
        }
        .studio-btn.primary {
            background: var(--studio-accent);
            color: #0f172a;
        }
        .studio-btn.secondary {
            border-color: rgba(15, 23, 42, 0.15);
        }
        .studio-btn.ghost {
            background: transparent;
            border-color: rgba(15, 23, 42, 0.15);
        }
        .studio-btn.toggle {
            display: flex;
            align-items: center;
            gap: 8px;
            border-color: rgba(15, 23, 42, 0.15);
            padding-left: 14px;
        }
        .record-dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background: var(--studio-muted);
            display: inline-block;
        }
        .studio-btn.toggle[data-recording="true"] {
            background: rgba(255, 92, 92, 0.15);
            border-color: rgba(255, 92, 92, 0.35);
            color: #ffbdbd;
        }
        .studio-btn.toggle[data-recording="true"] .record-dot {
            background: var(--studio-danger);
            box-shadow: 0 0 8px var(--studio-danger);
        }
        .studio-grid {
            display: grid;
            grid-template-columns: 220px minmax(0, 1fr) 320px;
            gap: 24px;
            flex: 1;
        }
        .studio-panel {
            background: var(--studio-panel);
            border: 1px solid var(--studio-border);
            border-radius: 24px;
            padding: 20px;
            display: flex;
            flex-direction: column;
            gap: 16px;
            box-shadow: 0 20px 50px var(--studio-shadow);
        }
        .studio-left h2,
        .studio-right h2 {
            margin: 0;
            font-size: 1rem;
            text-transform: uppercase;
            letter-spacing: 0.08em;
            color: var(--studio-muted);
        }
        .studio-muted {
            color: var(--studio-muted);
        }
        .destination-card {
            background: rgba(15, 23, 42, 0.03);
            border: 1px solid var(--studio-border);
            border-radius: 16px;
            padding: 14px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-weight: 600;
            color: var(--studio-text);
        }
        .destination-card span {
            color: var(--studio-muted);
            font-size: 0.85rem;
        }
        .destination-list {
            display: flex;
            flex-direction: column;
            gap: 12px;
            width: 100%;
        }
        .destination-card.connected {
            border-color: var(--studio-accent);
            background: rgba(245, 213, 71, 0.15);
        }
        .destination-card strong {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .destination-pill {
            display: inline-flex;
            align-items: center;
            gap: 4px;
            padding: 2px 10px;
            border-radius: 999px;
            font-size: 0.75rem;
            background: var(--studio-pill-bg);
            border: 1px solid var(--studio-border);
        }
        .destination-card.connected .destination-pill {
            border-color: rgba(76, 175, 80, 0.6);
            background: rgba(76, 175, 80, 0.15);
            color: #1a7f37;
        }
        .destination-empty {
            border: 1px dashed var(--studio-border);
            border-radius: 16px;
            padding: 18px;
            text-align: center;
            color: var(--studio-muted);
            font-size: 0.9rem;
        }
        .studio-stage {
            position: relative;
            background: var(--studio-panel);
            border-radius: 32px;
            padding: 24px;
            border: 1px solid var(--studio-border);
            display: flex;
            flex-direction: column;
            gap: 16px;
            box-shadow: 0 25px 60px var(--studio-shadow);
        }
        .stage-video {
            position: relative;
            border-radius: 24px;
            overflow: hidden;
            background: #000;
            min-height: 420px;
            border: 1px solid rgba(15, 23, 42, 0.12);
        }
        .stage-video video {
            width: 100%;
            height: 100%;
            object-fit: cover;
            display: block;
            background: #000;
        }
        .stage-watermark {
            position: absolute;
            top: 16px;
            right: 16px;
            display: inline-flex;
            align-items: center;
            gap: 8px;
            background: var(--studio-pill-bg);
            padding: 8px 16px;
            border-radius: 999px;
            font-weight: 600;
            border: 1px solid var(--studio-border);
            color: var(--studio-text);
        }
        .stage-watermark[data-hidden="true"] {
            display: none;
        }
        .watermark-text {
            cursor: text;
            border-bottom: 1px dashed transparent;
        }
        .watermark-text[data-editing="true"] {
            border-bottom-color: var(--studio-border);
        }
        .watermark-text:focus {
            outline: none;
            border-bottom-color: var(--studio-accent);
        }
        .watermark-remove {
            background: transparent;
            border: none;
            width: 24px;
            height: 24px;
            border-radius: 50%;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            font-size: 1rem;
            color: inherit;
            cursor: pointer;
            opacity: 0;
            transition: opacity 0.15s ease;
        }
        .stage-watermark:hover .watermark-remove {
            opacity: 0.85;
        }
        .video-fallback {
            position: absolute;
            inset: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            background: linear-gradient(135deg, rgba(15, 28, 51, 0.9), rgba(15, 28, 51, 0.6));
            color: var(--studio-muted);
            font-size: 1.1rem;
            text-align: center;
            padding: 0 40px;
        }
        .watermark-restore {
            align-self: flex-end;
            margin-top: -4px;
            margin-bottom: 8px;
        }
        .stage-footer {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding-top: 8px;
        }
        .status-pill {
            padding: 8px 14px;
            border-radius: 999px;
            background: var(--studio-pill-bg);
            font-size: 0.85rem;
            display: inline-flex;
            align-items: center;
            gap: 8px;
            border: 1px solid var(--studio-border);
        }
        .status-pill::before {
            content: '';
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: #4ade80;
        }
        .status-pill[data-state="live"]::before {
            background: #ef4444;
        }
        .studio-right .tool-stack {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }
        .tool-row {
            display: flex;
            gap: 12px;
            align-items: center;
            border: 1px solid var(--studio-border);
            border-radius: 18px;
            padding: 12px 14px;
            background: rgba(15, 23, 42, 0.02);
            cursor: pointer;
            text-align: left;
        }
        .tool-row:hover {
            border-color: var(--studio-accent-soft);
        }
        .tool-icon {
            width: 32px;
            height: 32px;
            border-radius: 12px;
            background: rgba(245, 213, 71, 0.2);
            display: inline-flex;
            align-items: center;
            justify-content: center;
            font-size: 1.1rem;
        }
        .scene-card {
            background: linear-gradient(135deg, rgba(245, 213, 71, 0.15), rgba(80, 160, 255, 0.18));
            border-radius: 18px;
            padding: 18px;
            border: 1px solid rgba(15, 23, 42, 0.08);
        }
        .scene-card h3 {
            margin: 0 0 6px;
        }
        .scene-card p {
            margin: 0;
            color: var(--studio-muted);
            font-size: 0.9rem;
        }
        .add-scene-btn {
            width: 100%;
            border-radius: 16px;
            padding: 12px;
            font-weight: 600;
            border: 1px dashed var(--studio-border);
            background: transparent;
            color: var(--studio-text);
            cursor: pointer;
        }
        .studio-toast {
            position: fixed;
            bottom: 24px;
            right: 24px;
            background: var(--studio-toast-bg);
            padding: 14px 18px;
            border-radius: 14px;
            border: 1px solid var(--studio-toast-border);
            opacity: 0;
            transform: translateY(20px);
            transition: opacity 0.2s ease, transform 0.2s ease;
            pointer-events: none;
            color: #f8fafc;
        }
        .studio-toast.visible {
            opacity: 1;
            transform: translateY(0);
        }
        @media (max-width: 1100px) {
            .studio-shell {
                padding: 20px;
            }
            .studio-grid {
                grid-template-columns: 1fr;
            }
            .studio-left,
            .studio-right {
                flex-direction: row;
                overflow-x: auto;
            }
            .studio-topbar {
                flex-direction: column;
                align-items: flex-start;
                gap: 16px;
            }
        }
        @media (max-width: 720px) {
            .studio-shell {
                padding: 14px;
                gap: 14px;
            }
            .studio-topbar {
                padding: 14px 16px;
                gap: 10px;
            }
            .topbar-actions {
                width: 100%;
                flex-wrap: wrap;
                gap: 8px;
            }
            .topbar-actions .studio-btn {
                flex: 1 1 calc(50% - 6px);
                min-width: 140px;
            }
            .studio-grid {
                gap: 14px;
            }
            .studio-stage {
                order: 1;
                padding: 16px;
            }
            .studio-left {
                order: 2;
                flex-direction: column;
                overflow: visible;
                gap: 12px;
            }
            .studio-right {
                order: 3;
                flex-direction: column;
                overflow: visible;
                gap: 12px;
            }
            .studio-panel {
                padding: 16px;
            }
            .stage-video {
                min-height: 240px;
                border-radius: 18px;
            }
            .stage-footer {
                flex-direction: column;
                align-items: flex-start;
                gap: 8px;
            }
            .studio-btn {
                width: 100%;
                justify-content: center;
            }
        }
    </style>
</head>
<body class="studio-body">
    <div class="studio-shell" id="studioShell">
        <header class="studio-topbar">
            <div class="studio-title">
                <button class="studio-back" id="studioBack" aria-label="Back to dashboard">&lt;</button>
                <div>
                    <h1 class="studio-stream-title">
                        <span id="studioStreamNameDisplay" class="studio-title-text" role="textbox" aria-label="Stream title" tabindex="0" data-editing="false"></span>
                    </h1>
                    <p id="studioModeLabel">Live preview</p>
                </div>
            </div>
            <div class="topbar-actions">
                <button class="studio-btn ghost" id="studioThemeToggle">Dark mode</button>
                <button class="studio-btn ghost" id="studioUpgradeButton">Go Pro</button>
                <button class="studio-btn toggle" id="recordToggle" aria-pressed="false">
                    <span class="record-dot" aria-hidden="true"></span>
                    <span id="recordToggleLabel">Record standby</span>
                </button>
                <button class="studio-btn secondary" id="topAddChannel">+ Channels</button>
                <button class="studio-btn secondary" id="scheduleButton">Schedule</button>
                <button class="studio-btn primary" id="goLiveButton">Go live</button>
            </div>
        </header>

        <div class="studio-grid">
            <aside class="studio-panel studio-left">
                <div>
                    <h2>Destinations</h2>
                    <p class="studio-muted">Route your feed anywhere.</p>
                </div>
                <button class="add-scene-btn" id="sidebarAddChannel">Add destination</button>
                <div id="destinationList" class="destination-list"></div>
                <div class="destination-empty" id="destinationEmptyState">
                    <p>No destinations linked yet.</p>
                    <small>Connect YouTube or Twitch from the dashboard to unlock multistreaming.</small>
                </div>
            </aside>

            <section class="studio-stage">
                <div class="stage-video">
                    <video id="studioFeed" autoplay playsinline muted></video>
                    <div class="stage-watermark" id="studioWatermark">
                        <span id="watermarkText" class="watermark-text" role="textbox" aria-label="Watermark text" tabindex="0">Lettuce Stream</span>
                        <button type="button" class="watermark-remove" id="watermarkRemove" aria-label="Remove watermark">√ó</button>
                    </div>
                    <div class="video-fallback" id="cameraFallback">Allow camera access to preview your studio feed.</div>
                </div>
                <button type="button" class="studio-btn ghost watermark-restore" id="restoreWatermarkButton" hidden>Restore watermark</button>
                <div class="stage-footer">
                    <div class="status-pill" id="previewStatus">Preview mode active</div>
                    <div class="studio-levels">
                        <small style="color: var(--studio-muted);">Audio mix ¬∑ ‚àí12 dB</small>
                    </div>
                </div>
            </section>

            <aside class="studio-panel studio-right">
                <button class="add-scene-btn" id="addSceneButton">+ Add scene</button>
                <div class="scene-card">
                    <h3>Starter welcome deck</h3>
                    <p>Drop your opening slide, sponsor card, or countdown here.</p>
                </div>
                <div class="tool-stack">
                    <button class="tool-row" data-tool="Graphics">
                        <span class="tool-icon" aria-hidden="true">üé®</span>
                        <div>
                            <strong>Graphics</strong>
                            <p style="margin:4px 0 0;color:var(--studio-muted);font-size:0.85rem;">Lower thirds, logo bugs, overlays.</p>
                        </div>
                    </button>
                    <button class="tool-row" data-tool="Captions">
                        <span class="tool-icon" aria-hidden="true">üí¨</span>
                        <div>
                            <strong>Captions</strong>
                            <p style="margin:4px 0 0;color:var(--studio-muted);font-size:0.85rem;">Auto-transcribe and pin quotes.</p>
                        </div>
                    </button>
                    <button class="tool-row" data-tool="QR Codes">
                        <span class="tool-icon" aria-hidden="true">üåÄ</span>
                        <div>
                            <strong>QR codes</strong>
                            <p style="margin:4px 0 0;color:var(--studio-muted);font-size:0.85rem;">Share links on-screen in seconds.</p>
                        </div>
                    </button>
                    <button class="tool-row" data-tool="Notes">
                        <span class="tool-icon" aria-hidden="true">üìù</span>
                        <div>
                            <strong>Notes</strong>
                            <p style="margin:4px 0 0;color:var(--studio-muted);font-size:0.85rem;">Keep your run of show handy.</p>
                        </div>
                    </button>
                </div>
            </aside>
        </div>
    </div>

    <div class="studio-toast" id="studioToast" role="status" aria-live="polite"></div>

    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-app-check-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-auth-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-storage-compat.js"></script>
    <script src="firebase-config.js"></script>
    <script src="storage-helpers.js"></script>
    <script>
        (function () {
            const DESTINATION_LIBRARY = {
                youtube: { label: 'YouTube', resolution: '1080p', supportsRelay: true },
                twitch: { label: 'Twitch', resolution: '1080p', supportsRelay: false },
                kick: { label: 'Kick', resolution: '720p', supportsRelay: false }
            };
            const STREAMABLE_DESTINATIONS = ['youtube'];
            const PAID_STATUS_KEYS = ['active', 'paid', 'upgraded', 'cancelling'];
            const THEME_STORAGE_KEY = 'lettuce-dashboard-theme';
            const params = new URLSearchParams(window.location.search);

            const dom = {
                streamTitle: document.getElementById('studioStreamNameDisplay'),
                streamMode: document.getElementById('studioModeLabel'),
                recordToggle: document.getElementById('recordToggle'),
                recordToggleLabel: document.getElementById('recordToggleLabel'),
                goLiveButton: document.getElementById('goLiveButton'),
                toast: document.getElementById('studioToast'),
                fallback: document.getElementById('cameraFallback'),
                video: document.getElementById('studioFeed'),
                themeToggle: document.getElementById('studioThemeToggle'),
                shell: document.getElementById('studioShell'),
                upgradeButton: document.getElementById('studioUpgradeButton'),
                watermarkContainer: document.getElementById('studioWatermark'),
                watermarkText: document.getElementById('watermarkText'),
                watermarkRemove: document.getElementById('watermarkRemove'),
                watermarkRestore: document.getElementById('restoreWatermarkButton'),
                destinationList: document.getElementById('destinationList'),
                destinationEmpty: document.getElementById('destinationEmptyState'),
                statusPill: document.getElementById('previewStatus')
            };

            const storageApi = window.storageHelpers || null;
            const bodyEl = document.body;

            const state = {
                activeUser: null,
                cameraStream: null,
                recorder: null,
                recordedChunks: [],
                recordingStartedAt: null,
                isRecording: false,
                isLive: false,
                liveRecorder: null,
                relaySocket: null,
                youtubeSession: null,
                liveChunkCount: 0,
                liveActionInFlight: false,
                runtimeConfig: {},
                runtimeConfigPromise: null,
                destinations: {},
                profileUnsubscribe: null,
                cameraInitialized: false,
                currentTitle: '',
                watermarkText: 'Lettuce Stream'
            };
            let trialExpiryTimerId = null;

            bootstrap();

            async function bootstrap() {
                const sessionTitle = params.get('title') ? decodeURIComponent(params.get('title')) : 'Untitled session';
                const modeParam = params.get('mode') === 'record' ? 'Record session' : 'Live preview';
                if (dom.streamMode) {
                    dom.streamMode.textContent = modeParam;
                }
                setStreamTitle(sessionTitle);
                initTitleEditing();
                initTheme();
                initWatermarkControls();
                wireButtons();
                await fetchRuntimeConfig();
                guardPaidUser();
            }

            function showToast(message) {
                if (!dom.toast) return;
                dom.toast.textContent = message;
                dom.toast.classList.add('visible');
                clearTimeout(showToast.timeoutId);
                showToast.timeoutId = setTimeout(() => dom.toast.classList.remove('visible'), 2600);
            }

            async function fetchRuntimeConfig() {
                if (state.runtimeConfigPromise) {
                    return state.runtimeConfigPromise;
                }
                state.runtimeConfigPromise = fetch('/api/runtime-config', { cache: 'no-store' })
                    .then((res) => (res.ok ? res.json() : {}))
                    .then((data) => {
                        state.runtimeConfig = data || {};
                        return state.runtimeConfig;
                    })
                    .catch(() => {
                        state.runtimeConfig = {};
                        return state.runtimeConfig;
                    });
                return state.runtimeConfigPromise;
            }

            function guardPaidUser() {
                if (typeof auth === 'undefined' || typeof db === 'undefined') {
                    showToast('Studio requires Firebase. Refresh to try again.');
                    return;
                }
                auth.onAuthStateChanged(async (user) => {
                    if (!user) {
                        detachProfileListener();
                        window.location.href = 'signin.html?next=studio';
                        return;
                    }
                    state.activeUser = user;
                    try {
                        const doc = await db.collection('users').doc(user.uid).get();
                        const profileData = doc.exists ? doc.data() : {};
                        const status = (profileData.status || 'trial').toLowerCase();
                        const trialEndsAt = parseTimestamp(profileData.trialEndsAt);
                        const now = new Date();
                        const trialActive = status === 'trial' && trialEndsAt && trialEndsAt > now;
                        const isPaid = trialActive || PAID_STATUS_KEYS.includes(status);
                        if (dom.upgradeButton) {
                            dom.upgradeButton.hidden = isPaid;
                        }
                        if (trialActive) {
                            scheduleTrialExpiry(trialEndsAt, user.uid);
                        } else {
                            clearTrialExpiryTimer();
                            if (status === 'trial') {
                                await expireTrialAccess(user.uid);
                            }
                        }
                        if (!isPaid) {
                            window.location.href = 'billing.html';
                            return;
                        }
                        subscribeToProfile(user.uid);
                        if (!state.cameraInitialized) {
                            state.cameraInitialized = true;
                            initCamera();
                        }
                    } catch (error) {
                        console.error('Unable to hydrate studio:', error);
                        showToast('Unable to load your workspace. Try refreshing.');
                    }
                });
            }

            function subscribeToProfile(uid) {
                detachProfileListener();
                state.profileUnsubscribe = db.collection('users').doc(uid).onSnapshot((snapshot) => {
                    const data = snapshot.data() || {};
                    state.destinations = data.channelConnections || {};
                    renderDestinations();
                    evaluateLiveAvailability();
                }, (error) => {
                    console.warn('Profile listener error:', error);
                });
            }

            function detachProfileListener() {
                if (state.profileUnsubscribe) {
                    state.profileUnsubscribe();
                    state.profileUnsubscribe = null;
                }
            }

            async function initCamera() {
                if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
                    if (dom.fallback) {
                        dom.fallback.textContent = 'Your browser does not support live preview. Try Chrome or Edge.';
                    }
                    return;
                }
                try {
                    state.cameraStream = await navigator.mediaDevices.getUserMedia({ video: { width: 1920, height: 1080 }, audio: true });
                    if (dom.video) {
                        dom.video.srcObject = state.cameraStream;
                    }
                    if (dom.fallback) {
                        dom.fallback.style.display = 'none';
                    }
                    showToast('Camera preview ready.');
                    evaluateLiveAvailability();
                } catch (error) {
                    console.warn('Camera access denied:', error);
                    if (dom.fallback) {
                        dom.fallback.textContent = 'We could not access your camera. Check permissions and reload.';
                    }
                }
            }

            function renderDestinations() {
                if (!dom.destinationList) {
                    return;
                }
                dom.destinationList.innerHTML = '';
                let connected = 0;
                Object.keys(DESTINATION_LIBRARY).forEach((key) => {
                    const definition = DESTINATION_LIBRARY[key];
                    const info = state.destinations[key];
                    const card = document.createElement('div');
                    card.className = 'destination-card';
                    if (info) {
                        card.classList.add('connected');
                        connected += 1;
                    }

                    const left = document.createElement('div');
                    const title = document.createElement('strong');
                    title.textContent = definition.label;
                    if (info?.title) {
                        const pill = document.createElement('span');
                        pill.className = 'destination-pill';
                        pill.textContent = info.title;
                        title.appendChild(pill);
                    }
                    const status = document.createElement('span');
                    status.textContent = info ? 'Connected' : 'Offline';
                    left.appendChild(title);
                    left.appendChild(status);

                    const resolution = document.createElement('span');
                    resolution.textContent = info?.resolution || definition.resolution;

                    card.appendChild(left);
                    card.appendChild(resolution);
                    dom.destinationList.appendChild(card);
                });

                if (dom.destinationEmpty) {
                    dom.destinationEmpty.hidden = connected > 0;
                }

                const available = STREAMABLE_DESTINATIONS.some((key) => Boolean(state.destinations[key]));
                if (!available && dom.statusPill) {
                    dom.statusPill.textContent = 'Preview mode ¬∑ No destinations linked';
                    dom.statusPill.dataset.state = 'preview';
                }
            }

            function parseTimestamp(value) {
                if (!value) {
                    return null;
                }
                if (typeof value.toDate === 'function') {
                    return value.toDate();
                }
                const parsed = new Date(value);
                return Number.isNaN(parsed.getTime()) ? null : parsed;
            }

            function clearTrialExpiryTimer() {
                if (trialExpiryTimerId) {
                    clearTimeout(trialExpiryTimerId);
                    trialExpiryTimerId = null;
                }
            }

            function scheduleTrialExpiry(deadline, userId) {
                clearTrialExpiryTimer();
                if (!(deadline instanceof Date)) {
                    return;
                }
                const msRemaining = deadline.getTime() - Date.now();
                if (msRemaining <= 0) {
                    enforceTrialLock(userId);
                    return;
                }
                trialExpiryTimerId = setTimeout(() => enforceTrialLock(userId), msRemaining);
            }

            async function enforceTrialLock(userId) {
                clearTrialExpiryTimer();
                await expireTrialAccess(userId);
                showToast('Your 24-hour preview has ended. Upgrade to keep streaming.');
                setTimeout(() => {
                    window.location.href = 'billing.html';
                }, 800);
            }

            async function expireTrialAccess(userId) {
                if (!userId) {
                    return;
                }
                try {
                    await db.collection('users').doc(userId).set({
                        status: 'expired',
                        plan: 'Trial',
                        cancelsAt: null
                    }, { merge: true });
                } catch (error) {
                    console.error('Unable to expire trial access:', error);
                }
            }

            function evaluateLiveAvailability() {
                if (!dom.goLiveButton) {
                    return;
                }
                if (state.isLive) {
                    dom.goLiveButton.disabled = false;
                    return;
                }
                const hasDestination = STREAMABLE_DESTINATIONS.some((key) => Boolean(state.destinations[key]));
                const hasRelay = Boolean(state.runtimeConfig?.relayUrl);
                const ready = Boolean(state.cameraStream) && hasDestination && hasRelay;
                dom.goLiveButton.disabled = !ready || state.liveActionInFlight;
                if (!ready) {
                    const reasons = [];
                    if (!state.cameraStream) {
                        reasons.push('allow camera access');
                    }
                    if (!hasDestination) {
                        reasons.push('connect YouTube');
                    }
                    if (!hasRelay) {
                        reasons.push('set STREAM_RELAY_URL');
                    }
                    dom.goLiveButton.title = `Cannot go live yet: ${reasons.join(', ')}.`;
                } else {
                    dom.goLiveButton.title = '';
                }
            }

            async function toggleGoLive() {
                if (state.liveActionInFlight) {
                    return;
                }
                if (state.isLive) {
                    await stopLiveStream();
                } else {
                    await startLiveStream();
                }
            }

            async function startLiveStream() {
                if (!state.activeUser) {
                    showToast('Sign in again to go live.');
                    return;
                }
                if (!state.cameraStream) {
                    showToast('Camera feed is not ready yet.');
                    return;
                }
                if (!state.destinations.youtube) {
                    showToast('Connect your YouTube channel in the dashboard to go live.');
                    return;
                }
                await fetchRuntimeConfig();
                if (!state.runtimeConfig.relayUrl) {
                    showToast('Streaming relay missing. Set STREAM_RELAY_URL in Vercel.');
                    return;
                }

                state.liveActionInFlight = true;
                updateLiveButtonBusy(true, 'Connecting‚Ä¶');
                try {
                    const idToken = await state.activeUser.getIdToken(true);
                    const response = await fetch('/api/youtube/start-broadcast', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ idToken, title: state.currentTitle })
                    });
                    const payload = await response.json();
                    if (!response.ok) {
                        throw new Error(payload?.error || 'Unable to start YouTube broadcast.');
                    }

                    state.youtubeSession = {
                        broadcastId: payload.broadcastId,
                        streamId: payload.streamId,
                        ingestionAddress: payload.ingestionAddress,
                        streamKey: payload.streamKey || payload.streamName || ''
                    };

                    await connectRelay(state.youtubeSession.ingestionAddress, state.youtubeSession.streamKey);
                    await startLiveRecorder();

                    state.isLive = true;
                    state.liveChunkCount = 0;
                    updateGoLiveButton();
                    setStatusPill('Warming up stream‚Ä¶', true);
                    showToast('YouTube stream warming up.');
                } catch (error) {
                    console.error('Unable to start live stream:', error);
                    showToast(error?.message || 'Unable to start stream.');
                    cleanupLiveSession();
                } finally {
                    state.liveActionInFlight = false;
                    updateLiveButtonBusy(false);
                    evaluateLiveAvailability();
                }
            }

            async function stopLiveStream() {
                state.liveActionInFlight = true;
                updateLiveButtonBusy(true, 'Ending‚Ä¶');
                try {
                    if (state.liveRecorder && state.liveRecorder.state !== 'inactive') {
                        state.liveRecorder.stop();
                    }
                    if (state.relaySocket && state.relaySocket.readyState === WebSocket.OPEN) {
                        state.relaySocket.send(JSON.stringify({ type: 'stop' }));
                        state.relaySocket.close();
                    }
                    await transitionBroadcast('complete');
                    showToast('Stream ended.');
                } catch (error) {
                    console.warn('Unable to stop live stream cleanly:', error);
                } finally {
                    cleanupLiveSession();
                    state.liveActionInFlight = false;
                    updateLiveButtonBusy(false);
                    evaluateLiveAvailability();
                }
            }

            function connectRelay(ingestionAddress, streamKey) {
                return new Promise((resolve, reject) => {
                    const relayUrl = state.runtimeConfig.relayUrl;
                    if (!relayUrl) {
                        reject(new Error('Relay URL missing.'));
                        return;
                    }
                    state.relaySocket = new WebSocket(relayUrl);
                    state.relaySocket.binaryType = 'arraybuffer';

                    const ingestPayload = {
                        type: 'start',
                        ingest: {
                            url: ingestionAddress,
                            streamKey
                        }
                    };

                    const timeout = setTimeout(() => {
                        reject(new Error('Relay connection timed out.'));
                    }, 10000);

                    state.relaySocket.addEventListener('open', () => {
                        clearTimeout(timeout);
                        state.relaySocket.send(JSON.stringify(ingestPayload));
                        resolve();
                    });

                    state.relaySocket.addEventListener('error', (event) => {
                        clearTimeout(timeout);
                        reject(new Error('Relay connection failed.'));
                    });

                    state.relaySocket.addEventListener('close', () => {
                        if (state.isLive) {
                            showToast('Relay closed. Ending stream.');
                            cleanupLiveSession();
                        }
                    });
                });
            }

            function startLiveRecorder() {
                return new Promise((resolve, reject) => {
                    if (typeof MediaRecorder === 'undefined') {
                        reject(new Error('MediaRecorder is not supported in this browser.'));
                        return;
                    }
                    try {
                        const mimeType = chooseLiveMime();
                        state.liveRecorder = mimeType ? new MediaRecorder(state.cameraStream, { mimeType }) : new MediaRecorder(state.cameraStream);
                    } catch (error) {
                        reject(new Error('Unable to initialize live recorder.'));
                        return;
                    }

                    state.liveRecorder.ondataavailable = async (event) => {
                        if (!event.data || event.data.size === 0) {
                            return;
                        }
                        if (state.relaySocket && state.relaySocket.readyState === WebSocket.OPEN) {
                            state.liveChunkCount += 1;
                            if (state.liveChunkCount === 4) {
                                transitionBroadcast('live');
                                setStatusPill('Live on YouTube ‚Ä¢ Stream health good', true);
                            }
                            try {
                                const buffer = await event.data.arrayBuffer();
                                state.relaySocket.send(buffer);
                            } catch (error) {
                                console.warn('Unable to send live chunk:', error);
                            }
                        }
                    };

                    state.liveRecorder.onstop = () => {
                        if (state.isLive) {
                            cleanupLiveSession();
                        }
                    };

                    state.liveRecorder.start(1000);
                    resolve();
                });
            }

            async function transitionBroadcast(nextStatus) {
                if (!state.youtubeSession || !state.activeUser) {
                    return;
                }
                const broadcastId = state.youtubeSession.broadcastId;
                if (!broadcastId) {
                    return;
                }
                try {
                    const idToken = await state.activeUser.getIdToken(true);
                    await fetch('/api/youtube/transition-broadcast', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ idToken, broadcastId, status: nextStatus })
                    });
                } catch (error) {
                    console.warn('Unable to update broadcast lifecycle:', error);
                }
            }

            function cleanupLiveSession() {
                state.isLive = false;
                state.youtubeSession = null;
                state.liveChunkCount = 0;
                if (state.liveRecorder) {
                    try {
                        if (state.liveRecorder.state !== 'inactive') {
                            state.liveRecorder.stop();
                        }
                    } catch (error) {
                        /* no-op */
                    }
                    state.liveRecorder = null;
                }
                if (state.relaySocket && state.relaySocket.readyState === WebSocket.OPEN) {
                    state.relaySocket.close();
                }
                state.relaySocket = null;
                setStatusPill('Preview mode active', false);
                updateGoLiveButton();
            }

            function updateGoLiveButton() {
                if (!dom.goLiveButton) {
                    return;
                }
                dom.goLiveButton.textContent = state.isLive ? 'End stream' : 'Go live';
                dom.goLiveButton.classList.toggle('secondary', state.isLive);
                dom.goLiveButton.classList.toggle('primary', !state.isLive);
            }

            function updateLiveButtonBusy(isBusy, label) {
                if (!dom.goLiveButton) {
                    return;
                }
                dom.goLiveButton.dataset.busy = String(Boolean(isBusy));
                if (isBusy && label) {
                    dom.goLiveButton.textContent = label;
                } else if (!isBusy) {
                    updateGoLiveButton();
                }
            }

            function chooseLiveMime() {
                const candidates = ['video/webm;codecs=vp9,opus', 'video/webm;codecs=vp8,opus', 'video/webm'];
                if (typeof MediaRecorder === 'undefined' || typeof MediaRecorder.isTypeSupported !== 'function') {
                    return '';
                }
                for (const type of candidates) {
                    if (MediaRecorder.isTypeSupported(type)) {
                        return type;
                    }
                }
                return '';
            }

            function setStatusPill(text, live) {
                if (!dom.statusPill) {
                    return;
                }
                dom.statusPill.textContent = text;
                dom.statusPill.dataset.state = live ? 'live' : 'preview';
            }

            function toggleRecording() {
                if (!state.cameraStream) {
                    showToast('Camera feed is not ready yet.');
                    return;
                }
                if (typeof MediaRecorder === 'undefined') {
                    showToast('Recording is not supported in this browser.');
                    return;
                }
                if (state.isRecording) {
                    stopRecording({ reason: 'Recording stopped' });
                } else {
                    startRecording();
                }
            }

            function startRecording() {
                try {
                    state.recordedChunks = [];
                    state.recorder = new MediaRecorder(state.cameraStream, { mimeType: 'video/webm;codecs=vp9,opus' });
                } catch (error) {
                    console.warn('Unable to initialize recorder with vp9, falling back.', error);
                    try {
                        state.recorder = new MediaRecorder(state.cameraStream);
                    } catch (fallbackError) {
                        console.error('Recording unavailable:', fallbackError);
                        showToast('Recording failed to start.');
                        return;
                    }
                }

                state.recorder.ondataavailable = (event) => {
                    if (event.data && event.data.size > 0) {
                        state.recordedChunks.push(event.data);
                    }
                };
                state.recorder.onstop = finalizeRecording;
                state.recorder.start();
                state.recordingStartedAt = Date.now();
                setRecordingState(true);
                showToast('Recording started.');
            }

            function stopRecording({ reason } = {}) {
                if (!state.recorder || state.recorder.state === 'inactive') {
                    return;
                }
                showToast(reason ? `${reason}. Finalizing‚Ä¶` : 'Finalizing recording‚Ä¶');
                state.recorder.stop();
            }

            async function finalizeRecording() {
                setRecordingState(false);
                if (!state.recordedChunks.length) {
                    showToast('Recording ended, but no video was captured.');
                    return;
                }
                const duration = state.recordingStartedAt ? Math.max(Date.now() - state.recordingStartedAt, 0) : 0;
                const mimeType = state.recorder?.mimeType || 'video/webm';
                const blob = new Blob(state.recordedChunks, { type: mimeType });
                const safeName = formatFileName(state.currentTitle);
                downloadRecordingBlob(blob, `${safeName}-${Date.now()}.webm`);
                await persistRecordingAsset(blob, { durationMs: duration, title: state.currentTitle });
                state.recordedChunks = [];
                state.recorder = null;
            }

            function setRecordingState(active) {
                state.isRecording = Boolean(active);
                if (dom.recordToggle) {
                    dom.recordToggle.dataset.recording = String(state.isRecording);
                    dom.recordToggle.setAttribute('aria-pressed', String(state.isRecording));
                }
                if (dom.recordToggleLabel) {
                    dom.recordToggleLabel.textContent = state.isRecording ? 'Recording‚Ä¶' : 'Record standby';
                }
            }

            function toggleTheme() {
                const nextTheme = bodyEl.dataset.theme === 'dark' ? 'light' : 'dark';
                applyTheme(nextTheme);
            }

            function applyTheme(nextTheme) {
                bodyEl.dataset.theme = nextTheme;
                if (dom.shell) {
                    dom.shell.dataset.theme = nextTheme;
                }
                if (dom.themeToggle) {
                    dom.themeToggle.textContent = nextTheme === 'dark' ? 'Light mode' : 'Dark mode';
                }
                try {
                    localStorage.setItem(THEME_STORAGE_KEY, nextTheme);
                } catch (error) {
                    console.warn('Unable to persist studio theme preference', error);
                }
            }

            function initTheme() {
                let storedTheme = 'light';
                try {
                    storedTheme = localStorage.getItem(THEME_STORAGE_KEY) || 'light';
                } catch (error) {
                    storedTheme = 'light';
                }
                applyTheme(storedTheme === 'dark' ? 'dark' : 'light');
            }

            function initTitleEditing() {
                if (!dom.streamTitle) {
                    return;
                }
                dom.streamTitle.addEventListener('click', beginTitleEdit);
                dom.streamTitle.addEventListener('keydown', (event) => {
                    if (event.key === 'Enter') {
                        event.preventDefault();
                        commitTitleEdit();
                    } else if (event.key === 'Escape') {
                        event.preventDefault();
                        commitTitleEdit({ revert: true });
                    }
                });
                dom.streamTitle.addEventListener('blur', () => {
                    if (dom.streamTitle.dataset.editing === 'true') {
                        commitTitleEdit();
                    }
                });
            }

            function beginTitleEdit() {
                if (!dom.streamTitle || dom.streamTitle.dataset.editing === 'true') {
                    return;
                }
                dom.streamTitle.dataset.editing = 'true';
                dom.streamTitle.setAttribute('contenteditable', 'true');
                dom.streamTitle.focus();
                const range = document.createRange();
                range.selectNodeContents(dom.streamTitle);
                const selection = window.getSelection();
                selection.removeAllRanges();
                selection.addRange(range);
            }

            function commitTitleEdit({ revert = false } = {}) {
                if (!dom.streamTitle) {
                    return;
                }
                const nextValue = revert ? state.currentTitle : (dom.streamTitle.textContent || '').trim() || 'Untitled session';
                setStreamTitle(nextValue);
                dom.streamTitle.dataset.editing = 'false';
                dom.streamTitle.removeAttribute('contenteditable');
            }

            function setStreamTitle(value) {
                state.currentTitle = value;
                if (dom.streamTitle) {
                    dom.streamTitle.textContent = value;
                }
                document.title = `${value} ¬∑ Lettuce Stream Studio`;
            }

            function initWatermarkControls() {
                if (!dom.watermarkText) {
                    return;
                }
                setWatermarkText(state.watermarkText);
                dom.watermarkText.addEventListener('click', beginWatermarkEdit);
                dom.watermarkText.addEventListener('keydown', (event) => {
                    if (event.key === 'Enter') {
                        event.preventDefault();
                        commitWatermarkEdit();
                    } else if (event.key === 'Escape') {
                        event.preventDefault();
                        commitWatermarkEdit({ revert: true });
                    }
                });
                dom.watermarkText.addEventListener('blur', () => {
                    if (dom.watermarkText.dataset.editing === 'true') {
                        commitWatermarkEdit();
                    }
                });
                if (dom.watermarkRemove) {
                    dom.watermarkRemove.addEventListener('click', (event) => {
                        event.stopPropagation();
                        removeWatermark();
                    });
                }
                if (dom.watermarkRestore) {
                    dom.watermarkRestore.addEventListener('click', restoreWatermark);
                }
            }

            function beginWatermarkEdit() {
                if (!dom.watermarkText || dom.watermarkText.dataset.editing === 'true') {
                    return;
                }
                dom.watermarkText.dataset.editing = 'true';
                dom.watermarkText.setAttribute('contenteditable', 'true');
                dom.watermarkText.focus();
                const range = document.createRange();
                range.selectNodeContents(dom.watermarkText);
                const selection = window.getSelection();
                selection.removeAllRanges();
                selection.addRange(range);
            }

            function commitWatermarkEdit({ revert = false } = {}) {
                if (!dom.watermarkText) {
                    return;
                }
                const nextValue = revert ? state.watermarkText : (dom.watermarkText.textContent || '').trim() || 'Lettuce Stream';
                setWatermarkText(nextValue);
                dom.watermarkText.dataset.editing = 'false';
                dom.watermarkText.removeAttribute('contenteditable');
            }

            function setWatermarkText(value) {
                state.watermarkText = value;
                if (dom.watermarkText) {
                    dom.watermarkText.textContent = value;
                }
            }

            function removeWatermark() {
                if (dom.watermarkContainer) {
                    dom.watermarkContainer.setAttribute('data-hidden', 'true');
                }
                if (dom.watermarkRestore) {
                    dom.watermarkRestore.hidden = false;
                }
                showToast('Watermark removed for this session.');
            }

            function restoreWatermark() {
                if (dom.watermarkContainer) {
                    dom.watermarkContainer.removeAttribute('data-hidden');
                }
                if (dom.watermarkRestore) {
                    dom.watermarkRestore.hidden = true;
                }
                showToast('Watermark restored.');
            }

            function wireButtons() {
                const backBtn = document.getElementById('studioBack');
                if (backBtn) {
                    backBtn.addEventListener('click', () => window.location.href = 'dashboard.html');
                }
                if (dom.recordToggle) {
                    dom.recordToggle.addEventListener('click', toggleRecording);
                }
                if (dom.goLiveButton) {
                    dom.goLiveButton.addEventListener('click', toggleGoLive);
                }
                if (dom.themeToggle) {
                    dom.themeToggle.addEventListener('click', toggleTheme);
                }
                if (dom.upgradeButton) {
                    dom.upgradeButton.addEventListener('click', () => {
                        window.location.href = 'plans.html#billing';
                    });
                }
                const addChannelButtons = [document.getElementById('topAddChannel'), document.getElementById('sidebarAddChannel')];
                addChannelButtons.forEach((btn) => {
                    if (!btn) return;
                    btn.addEventListener('click', () => {
                        window.open('dashboard.html#channels', '_blank');
                        showToast('Channel picker opened in a new tab.');
                    });
                });
                const scheduleButton = document.getElementById('scheduleButton');
                if (scheduleButton) {
                    scheduleButton.addEventListener('click', () => {
                        window.open('dashboard.html#scheduleLab', '_blank');
                        showToast('Scheduler opened.');
                    });
                }
                const addSceneButton = document.getElementById('addSceneButton');
                if (addSceneButton) {
                    addSceneButton.addEventListener('click', () => showToast('Scene library coming soon.'));
                }
                document.querySelectorAll('.tool-row').forEach((row) => {
                    row.addEventListener('click', () => {
                        const label = row.dataset.tool || 'Tool';
                        showToast(`${label} controls are part of the Pro toolkit.`);
                    });
                });
            }

            async function persistRecordingAsset(blob, metadata = {}) {
                if (!storageApi || !state.activeUser) {
                    return;
                }
                const title = metadata.title || 'Session recording';
                try {
                    await storageApi.uploadAsset(state.activeUser.uid, blob, {
                        kind: 'recording',
                        title,
                        fileName: `${formatFileName(title)}.webm`,
                        mimeType: blob.type,
                        durationMs: metadata.durationMs || 0
                    });
                } catch (error) {
                    if (error?.code === 'STORAGE_QUOTA_EXCEEDED') {
                        showToast('Recording was not saved. Storage limit reached.');
                        return;
                    }
                    console.warn('Unable to store recording in cloud:', error);
                }
            }

            function downloadRecordingBlob(blob, filename) {
                const url = URL.createObjectURL(blob);
                const anchor = document.createElement('a');
                anchor.href = url;
                anchor.download = filename;
                document.body.appendChild(anchor);
                anchor.click();
                anchor.remove();
                setTimeout(() => URL.revokeObjectURL(url), 0);
            }

            function formatFileName(text) {
                return (text || 'session').toLowerCase().replace(/[^a-z0-9]+/g, '-').replace(/^-+|-+$/g, '') || 'session';
            }

            window.addEventListener('beforeunload', () => {
                if (state.isRecording) {
                    stopRecording({ reason: 'Window closing' });
                }
                if (state.isLive) {
                    cleanupLiveSession();
                }
                if (state.cameraStream) {
                    state.cameraStream.getTracks().forEach((track) => track.stop());
                }
            });
        })();
    </script>
</body>
</html>
