<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dashboard - Lettuce Stream</title>
    <link rel="stylesheet" href="styles.css">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Space+Grotesk:wght@400;500;600;700&family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
</head>
<body class="dashboard-body" data-theme="light">
    <div class="dashboard-atmosphere"></div>
    <div class="dashboard-shell">
        <aside class="dashboard-sidebar">
            <div class="sidebar-brand">
                <svg width="36" height="36" viewBox="0 0 32 32" fill="none" xmlns="http://www.w3.org/2000/svg">
                    <rect width="32" height="32" rx="8" fill="#F5D547"/>
                    <path d="M12 9L22 16L12 23V9Z" fill="#0F172A"/>
                </svg>
                <span>Lettuce Stream</span>
            </div>
            <div class="sidebar-user" id="sidebarUser">
                <div class="user-initial" id="sidebarUserInitial"></div>
                <button class="user-meta-button" id="userMenuButton" aria-haspopup="true" aria-expanded="false">
                    <p class="user-name" id="sidebarUserName"></p>
                    <p class="user-plan" id="sidebarUserPlan"></p>
                </button>
                <div class="user-dropdown" id="userDropdown" role="menu">
                    <button type="button" data-user-action="billing">Billing</button>
                    <button type="button" data-user-action="settings">Settings</button>
                    <button type="button" data-user-action="logout">Log Out</button>
                </div>
            </div>
            <p class="sidebar-section-label">The Lake</p>
            <nav class="sidebar-nav" aria-label="Primary">
                <a class="sidebar-nav-item active" href="dashboard.html" aria-current="page">
                    <span class="nav-icon" aria-hidden="true">üè†</span>
                    <span>Home</span>
                </a>
                <a class="sidebar-nav-item" href="dashboard.html#channels">
                    <span class="nav-icon" aria-hidden="true">üì°</span>
                    <span>Channels</span>
                </a>
                <a class="sidebar-nav-item" href="dashboard.html#analytics">
                    <span class="nav-icon" aria-hidden="true">üìä</span>
                    <span>Analytics</span>
                </a>
                <a class="sidebar-nav-item" href="dashboard.html#storage">
                    <span class="nav-icon" aria-hidden="true">üíæ</span>
                    <span>Storage</span>
                </a>
            </nav>
            <button class="sidebar-upgrade" data-upgrade-trigger>Upgrade Account</button>
        </aside>
        <main class="dashboard-main">
            <header class="dashboard-header">
                <div>
                    <p class="eyebrow">Control Center</p>
                    <h1>Welcome back, <span id="primaryUserName"></span> üëã</h1>
                    <p class="subtitle">Connect every platform, plan your next show, and monitor upcoming experiences from one canvas.</p>
                </div>
                <div class="header-actions">
                    <button type="button" class="theme-toggle" id="themeToggle" aria-pressed="false" aria-label="Toggle color theme">
                        <span class="theme-toggle-icon" id="themeToggleIcon">‚òÄÔ∏è</span>
                        <span class="theme-toggle-label" id="themeToggleLabel">Light mode</span>
                    </button>
                    <div class="plan-badge" id="planBadge"></div>
                </div>
            </header>

            <section class="panel">
                <div class="section-heading">
                    <div>
                        <p class="eyebrow">Destinations</p>
                        <h2>Connect your platforms</h2>
                        <p class="subtitle">TikTok, Instagram, Meta, Snapchat, YouTube, Twitch, Kick, and LinkedIn are all ready to sync.</p>
                    </div>
                </div>
                <div class="platform-grid">
                    <article class="platform-card lock-required" data-platform-card="TikTok">
                        <div class="platform-icon">TT</div>
                        <div>
                            <h3>TikTok</h3>
                            <p>Reach vertical-first audiences in seconds.</p>
                        </div>
                        <button class="platform-connect" data-platform="TikTok">Connect</button>
                    </article>
                    <article class="platform-card lock-required" data-platform-card="Instagram">
                        <div class="platform-icon">IG</div>
                        <div>
                            <h3>Instagram</h3>
                            <p>Stories, reels, and live in one tap.</p>
                        </div>
                        <button class="platform-connect" data-platform="Instagram">Connect</button>
                    </article>
                    <article class="platform-card lock-required" data-platform-card="Meta">
                        <div class="platform-icon">FB</div>
                        <div>
                            <h3>Meta</h3>
                            <p>Stream to Facebook pages and groups.</p>
                        </div>
                        <button class="platform-connect" data-platform="Meta">Connect</button>
                    </article>
                    <article class="platform-card lock-required" data-platform-card="Snapchat">
                        <div class="platform-icon">SC</div>
                        <div>
                            <h3>Snapchat</h3>
                            <p>Amplify highlights across Spotlight.</p>
                        </div>
                        <button class="platform-connect" data-platform="Snapchat">Connect</button>
                    </article>
                    <article class="platform-card lock-required" data-platform-card="YouTube">
                        <div class="platform-icon">YT</div>
                        <div>
                            <h3>YouTube</h3>
                            <p>Broadcast long-form and shorts simultaneously.</p>
                        </div>
                        <button class="platform-connect" data-platform="YouTube">Connect</button>
                    </article>
                    <article class="platform-card lock-required" data-platform-card="Twitch">
                        <div class="platform-icon">TW</div>
                        <div>
                            <h3>Twitch</h3>
                            <p>Engage your core community live.</p>
                        </div>
                        <button class="platform-connect" data-platform="Twitch">Connect</button>
                    </article>
                    <article class="platform-card lock-required" data-platform-card="Kick">
                        <div class="platform-icon">KK</div>
                        <div>
                            <h3>Kick</h3>
                            <p>Tap into new monetization formats.</p>
                        </div>
                        <button class="platform-connect" data-platform="Kick">Connect</button>
                    </article>
                    <article class="platform-card lock-required" data-platform-card="LinkedIn">
                        <div class="platform-icon">IN</div>
                        <div>
                            <h3>LinkedIn</h3>
                            <p>Host executive town halls and launches.</p>
                        </div>
                        <button class="platform-connect" data-platform="LinkedIn">Connect</button>
                    </article>
                </div>
            </section>

            <section class="panel stream-lab">
                <div class="lab-card lock-required" id="liveLab">
                    <div class="lab-header">
                        <div>
                            <p class="eyebrow">Studio</p>
                            <h3>Go live or record</h3>
                        </div>
                        <span class="chip">Browser-based</span>
                    </div>
                    <form id="liveForm" class="lab-body">
                        <label class="field">
                            <span>Session title</span>
                            <input type="text" id="liveTitle" placeholder="Morning sync with community" required />
                        </label>
                        <div class="mode-picker">
                            <label>
                                <input type="radio" name="liveMode" value="live" checked>
                                <span>Go Live</span>
                            </label>
                            <label>
                                <input type="radio" name="liveMode" value="record">
                                <span>Record Only</span>
                            </label>
                        </div>
                        <button type="submit" class="btn-primary">Launch studio</button>
                    </form>
                </div>
                <div class="lab-card lock-required" id="scheduleLab">
                    <div class="lab-header">
                        <div>
                            <p class="eyebrow">Scheduler</p>
                            <h3>Schedule videos & playlists</h3>
                        </div>
                        <span class="chip chip-outline">Automation</span>
                    </div>
                    <form id="scheduleForm" class="lab-body">
                        <label class="field">
                            <span>Stream title</span>
                            <input type="text" id="scheduleTitle" placeholder="Product teaser" required />
                        </label>
                        <label class="field">
                            <span>Source</span>
                            <select id="scheduleSource">
                                <option value="video">Upload a video</option>
                                <option value="playlist">Use a playlist</option>
                            </select>
                        </label>
                        <label class="field">
                            <span>Start time</span>
                            <input type="datetime-local" id="scheduleTime" required />
                        </label>
                        <button type="submit" class="btn-secondary">Schedule stream</button>
                    </form>
                </div>
            </section>

            <section class="panel upcoming">
                <div class="section-heading">
                    <div>
                        <p class="eyebrow">Pipeline</p>
                        <h2>Upcoming experiences</h2>
                        <p class="subtitle">Imported events land here once you start scheduling.</p>
                    </div>
                </div>
                <div class="timeline" id="timeline">
                    <div class="timeline-empty">
                        <p>No sessions scheduled yet.</p>
                        <span>Everything you schedule or record will surface here automatically.</span>
                    </div>
                </div>
            </section>
        </main>
    </div>

    <div class="toast" id="toast" role="status" aria-live="polite"></div>

    <!-- Firebase SDK -->
    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-auth-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore-compat.js"></script>
    <script src="https://js.stripe.com/v3/"></script>

    <script src="firebase-config.js"></script>
    <script src="auth-helpers.js"></script>
    <script src="auth.js"></script>
    <script>
        const dashboardState = {
            requiresUpgrade: true,
            userId: null,
            plan: 'Trial',
            status: 'trial',
            cancelsAt: null,
            hasSyncedExpiration: false
        };

        const bodyElement = document.body;
        const themeToggle = document.getElementById('themeToggle');
        const themeToggleIcon = document.getElementById('themeToggleIcon');
        const themeToggleLabel = document.getElementById('themeToggleLabel');
        const userMenuButton = document.getElementById('userMenuButton');
        const userDropdown = document.getElementById('userDropdown');
        const sidebarUpgradeButton = document.querySelector('.sidebar-upgrade');
        const upgradeTriggers = document.querySelectorAll('[data-upgrade-trigger]');
        const THEME_STORAGE_KEY = 'lettuce-dashboard-theme';
        const PROFILE_CACHE_KEY = 'lettuce-user-cache';
        const OAUTH_REDIRECT_URI = `${window.location.origin}/oauth-callback.html`;
        const integrationState = {};
        const oauthProviders = {
            youtube: {
                provider: 'YouTube',
                endpoint: '/api/oauth-youtube',
                scopes: 'https://www.googleapis.com/auth/youtube'
            },
            twitch: {
                provider: 'Twitch',
                endpoint: '/api/oauth-twitch',
                scopes: 'user:read:email channel:manage:broadcast'
            }
        };

        initTheme();
        initUserMenu();

        upgradeTriggers.forEach((btn) => {
            btn.addEventListener('click', () => initiateUpgrade());
        });

        document.querySelectorAll('[data-platform]').forEach((btn) => {
            btn.addEventListener('click', () => handlePlatformConnect(btn.dataset.platform));
        });

        document.getElementById('liveForm').addEventListener('submit', (event) => {
            event.preventDefault();
            const title = document.getElementById('liveTitle').value;
            const mode = document.querySelector('input[name="liveMode"]:checked').value;
            handleStreamAction(`${mode === 'live' ? 'Going live' : 'Recording'}: ${title}`);
        });

        document.getElementById('scheduleForm').addEventListener('submit', (event) => {
            event.preventDefault();
            const title = document.getElementById('scheduleTitle').value;
            const time = document.getElementById('scheduleTime').value;
            handleStreamAction(`Scheduled "${title}" for ${time || 'your selected time'}`);
        });

        auth.onAuthStateChanged(async (user) => {
            if (!user) {
                window.location.href = 'signin.html';
                return;
            }

            dashboardState.userId = user.uid;
            applyCachedProfile(user);
            const profileSnap = await db.collection('users').doc(user.uid).get();
            const profile = profileSnap.exists ? profileSnap.data() : {};
            hydrateUser(user, profile);
            persistProfileCache(user.uid, profile);
            await loadIntegrationStatuses();
        });

        function hydrateUser(user, profile = {}) {
            const derivedName = profile.fullName || user.displayName || '';
            const emailHandle = user.email ? user.email.split('@')[0] : '';
            const name = derivedName || emailHandle;
            const plan = (profile.plan || 'Trial');
            const status = (profile.status || 'trial').toLowerCase();
            const cancelsAt = parseTimestamp(profile.cancelsAt);
            const avatarChoice = profile.avatar || '';
            const now = new Date();
            const statusWhitelist = ['active', 'paid', 'upgraded'];
            let upgraded = statusWhitelist.includes(status);
            const isCancelling = status === 'cancelling';

            if (isCancelling) {
                if (cancelsAt && cancelsAt > now) {
                    upgraded = true;
                } else if (cancelsAt && cancelsAt <= now && !dashboardState.hasSyncedExpiration) {
                    upgraded = false;
                    dashboardState.hasSyncedExpiration = true;
                    markSubscriptionExpired(user.uid);
                }
            }

            dashboardState.requiresUpgrade = !upgraded;
            dashboardState.plan = plan;
            dashboardState.status = status;
            dashboardState.cancelsAt = cancelsAt;

            const initialSource = name || (user.email || '');
            const initialChar = initialSource.trim().charAt(0).toUpperCase();

            document.getElementById('primaryUserName').textContent = name || user.email || '';
            document.getElementById('sidebarUserName').textContent = name || user.email || '';

            const avatarElement = document.getElementById('sidebarUserInitial');
            if (avatarElement) {
                if (avatarChoice) {
                    avatarElement.textContent = avatarChoice;
                    avatarElement.classList.add('avatar-icon');
                } else {
                    avatarElement.textContent = initialChar;
                    avatarElement.classList.remove('avatar-icon');
                }
            }
            updatePlanBadges({ plan, upgraded, isCancelling, cancelsAt });

            toggleLockState();
            toggleUpgradeCues();
        }

        function toggleLockState() {
            document.querySelectorAll('.lock-required').forEach((element) => {
                element.classList.toggle('locked', dashboardState.requiresUpgrade);
            });
        }

        function handlePlatformConnect(platform) {
            const providerKey = normalizeProvider(platform);
            if (dashboardState.requiresUpgrade) {
                showToast(`Upgrade to connect ${platform}.`);
                return;
            }

            if (!providerKey || !oauthProviders[providerKey]) {
                showToast(`${platform} connections are coming soon.`);
                return;
            }

            if (!dashboardState.userId) {
                showToast('Please sign in again to connect this platform.');
                return;
            }

            const button = document.querySelector(`[data-platform-card="${platform}"] .platform-connect`);
            setButtonPending(button, true);

            const isConnected = integrationState[providerKey]?.connected;
            if (isConnected) {
                disconnectIntegration(providerKey, platform).finally(() => setButtonPending(button, false));
                return;
            }

            launchOAuthFlow(providerKey, platform, button);
        }

        async function launchOAuthFlow(providerKey, platform, button) {
            try {
                const state = `${providerKey}-${generateStateToken()}`;
                const authorizationUrl = await requestAuthorizationUrl(providerKey, state);

                if (!authorizationUrl) {
                    throw new Error('Unable to start authorization.');
                }

                const popup = openOAuthPopup(authorizationUrl);
                if (!popup) {
                    showToast('Enable pop-ups to connect this platform.');
                    return;
                }

                const result = await waitForOAuthCode(state);
                if (!result?.code) {
                    throw new Error(result?.error || 'Authorization code missing.');
                }

                await exchangeAuthorizationCode(providerKey, result.code);
                await loadIntegrationStatus(providerKey, true);
                showToast(`${platform} connected successfully!`);
            } catch (error) {
                console.error('Unable to connect platform:', error);
                showToast(`Unable to connect ${platform}. Please try again.`);
            } finally {
                setButtonPending(button, false);
            }
        }

        async function disconnectIntegration(providerKey, platform) {
            const config = oauthProviders[providerKey];
            const button = document.querySelector(`[data-platform-card="${platform}"] .platform-connect`);
            try {
                const idToken = await auth.currentUser.getIdToken();
                const response = await fetch(config.endpoint, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${idToken}`
                    },
                    body: JSON.stringify({ action: 'disconnect' })
                });

                if (!response.ok) {
                    throw new Error('Failed to disconnect integration');
                }

                integrationState[providerKey] = { connected: false };
                updatePlatformButton(providerKey, platform);
                showToast(`${platform} disconnected.`);
            } catch (error) {
                console.error('Disconnect failed:', error);
                showToast(`Unable to disconnect ${platform}.`);
            } finally {
                setButtonPending(button, false);
            }
        }

        async function requestAuthorizationUrl(providerKey, state) {
            const config = oauthProviders[providerKey];
            try {
                const response = await fetch(config.endpoint, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        action: 'start',
                        redirectUri: OAUTH_REDIRECT_URI,
                        state
                    })
                });

                if (!response.ok) {
                    throw new Error('Authorization URL request failed');
                }

                const data = await response.json();
                return data.authorizationUrl;
            } catch (error) {
                console.error('Unable to request authorization URL:', error);
                return '';
            }
        }

        async function exchangeAuthorizationCode(providerKey, code) {
            const config = oauthProviders[providerKey];
            const idToken = await auth.currentUser.getIdToken();
            const response = await fetch(config.endpoint, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'Authorization': `Bearer ${idToken}`
                },
                body: JSON.stringify({
                    action: 'exchange',
                    code,
                    redirectUri: OAUTH_REDIRECT_URI
                })
            });

            if (!response.ok) {
                const details = await response.text();
                throw new Error(details || 'Token exchange failed');
            }
        }

        async function loadIntegrationStatuses() {
            const supportedProviders = Object.keys(oauthProviders);
            if (!dashboardState.userId) {
                return;
            }

            await Promise.all(supportedProviders.map((providerKey) => loadIntegrationStatus(providerKey)));
        }

        async function loadIntegrationStatus(providerKey, skipRefreshCheck = false) {
            const providerLabel = oauthProviders[providerKey]?.provider || providerKey;
            const doc = await db.collection('users')
                .doc(dashboardState.userId)
                .collection('integrations')
                .doc(providerKey)
                .get();

            let data = doc.exists ? doc.data() : null;
            const expiresAt = parseTimestamp(data?.expiresAt);

            if (data && !skipRefreshCheck && expiresAt && expiresAt < new Date()) {
                await refreshIntegration(providerKey);
                const refreshedDoc = await db.collection('users')
                    .doc(dashboardState.userId)
                    .collection('integrations')
                    .doc(providerKey)
                    .get();
                data = refreshedDoc.exists ? refreshedDoc.data() : null;
            }

            integrationState[providerKey] = {
                connected: Boolean(data),
                expiresAt: parseTimestamp(data?.expiresAt) || null,
                scope: data?.scope || ''
            };

            updatePlatformButton(providerKey, providerLabel);
        }

        async function refreshIntegration(providerKey) {
            const config = oauthProviders[providerKey];
            try {
                const idToken = await auth.currentUser.getIdToken();
                await fetch(config.endpoint, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${idToken}`
                    },
                    body: JSON.stringify({ action: 'refresh' })
                });
            } catch (error) {
                console.error('Unable to refresh integration token:', error);
            }
        }

        function openOAuthPopup(url) {
            const width = 480;
            const height = 720;
            const left = (window.screen.width / 2) - (width / 2);
            const top = (window.screen.height / 2) - (height / 2);
            return window.open(
                url,
                'oauthPopup',
                `toolbar=0,location=0,menubar=0,width=${width},height=${height},left=${left},top=${top}`
            );
        }

        function waitForOAuthCode(expectedState) {
            return new Promise((resolve, reject) => {
                const timeout = setTimeout(() => {
                    cleanup();
                    reject(new Error('Authorization timed out.'));
                }, 180000);

                function cleanup() {
                    clearTimeout(timeout);
                    window.removeEventListener('message', handleMessage);
                }

                function handleMessage(event) {
                    if (event.origin !== window.location.origin) {
                        return;
                    }

                    const data = event.data || {};
                    if (data.type !== 'oauthCallback' || data.state !== expectedState) {
                        return;
                    }

                    cleanup();
                    resolve(data);
                }

                window.addEventListener('message', handleMessage);
            });
        }

        function updatePlatformButton(providerKey, platformLabel) {
            const card = document.querySelector(`[data-platform-card="${platformLabel}"]`);
            const button = card ? card.querySelector('.platform-connect') : null;
            const isConnected = Boolean(integrationState[providerKey]?.connected);

            if (card) {
                card.classList.toggle('connected', isConnected);
            }

            if (button) {
                button.dataset.connected = String(isConnected);
                button.textContent = isConnected ? 'Disconnect' : 'Connect';
            }
        }

        function setButtonPending(button, pending) {
            if (!button) {
                return;
            }
            const defaultLabel = button.dataset.connected === 'true' ? 'Disconnect' : 'Connect';
            button.disabled = pending;
            button.textContent = pending ? 'Working‚Ä¶' : defaultLabel;
        }

        function normalizeProvider(label = '') {
            const normalized = label.toLowerCase();
            if (normalized.includes('youtube')) return 'youtube';
            if (normalized.includes('twitch')) return 'twitch';
            return '';
        }

        function generateStateToken() {
            if (window.crypto && typeof window.crypto.randomUUID === 'function') {
                return window.crypto.randomUUID();
            }
            return Math.random().toString(36).slice(2);
        }

        function handleStreamAction(message) {
            if (dashboardState.requiresUpgrade) {
                showToast('Upgrade to unlock streaming tools.');
                return;
            }
            showToast(message);
            appendTimelineItem(message);
        }

        function appendTimelineItem(message) {
            const timeline = document.getElementById('timeline');
            const emptyState = document.querySelector('.timeline-empty');
            if (emptyState) {
                emptyState.remove();
            }
            const card = document.createElement('div');
            card.className = 'timeline-card';
            card.innerHTML = `<strong>${message}</strong><span>${new Date().toLocaleString()}</span>`;
            timeline.prepend(card);
        }

        function initiateUpgrade() {
            if (typeof redirectToStripeCheckout === 'function' && dashboardState.userId) {
                redirectToStripeCheckout(dashboardState.userId, 'pro');
            } else {
                window.location.href = 'signup.html?plan=pro';
            }
        }

        function toggleUpgradeCues() {
            const needsUpgrade = dashboardState.requiresUpgrade;
            if (sidebarUpgradeButton) {
                sidebarUpgradeButton.style.display = needsUpgrade ? 'flex' : 'none';
                sidebarUpgradeButton.setAttribute('aria-hidden', String(!needsUpgrade));
            }
            upgradeTriggers.forEach((btn) => {
                btn.disabled = !needsUpgrade;
                btn.setAttribute('aria-hidden', String(!needsUpgrade));
                btn.style.display = needsUpgrade ? '' : 'none';
            });
        }

        function updatePlanBadges({ plan, upgraded, isCancelling, cancelsAt }) {
            const sidebarPlan = document.getElementById('sidebarUserPlan');
            const planBadge = document.getElementById('planBadge');
            const hasPaidPlan = Boolean(upgraded);
            const baseLabel = hasPaidPlan ? capitalize(plan) : 'Upgrade now';
            const cancelLabel = cancelsAt ? `Ends ${formatDate(cancelsAt)}` : baseLabel;

            if (sidebarPlan) {
                sidebarPlan.textContent = isCancelling && cancelsAt ? 'Cancels soon' : baseLabel;
            }

            if (planBadge) {
                planBadge.textContent = isCancelling && cancelsAt ? cancelLabel : baseLabel;
            }
        }

        function parseTimestamp(value) {
            if (!value) {
                return null;
            }
            if (typeof value.toDate === 'function') {
                return value.toDate();
            }
            const parsed = new Date(value);
            return Number.isNaN(parsed.getTime()) ? null : parsed;
        }

        function formatDate(date) {
            if (!(date instanceof Date)) {
                return '';
            }
            return date.toLocaleDateString(undefined, { month: 'short', day: 'numeric' });
        }

        async function markSubscriptionExpired(userId) {
            if (!userId) {
                return;
            }
            try {
                await db.collection('users').doc(userId).set({
                    status: 'expired',
                    plan: 'Trial',
                    cancelsAt: null
                }, { merge: true });
            } catch (error) {
                console.error('Unable to mark subscription expired:', error);
            }
        }

        function applyCachedProfile(user) {
            const cachedProfile = readProfileFromCache(user.uid);
            if (cachedProfile) {
                hydrateUser(user, cachedProfile);
                return true;
            }
            return false;
        }

        function persistProfileCache(userId, profile) {
            const cache = getProfileCache();
            cache[userId] = sanitizeProfileForCache(profile);
            try {
                localStorage.setItem(PROFILE_CACHE_KEY, JSON.stringify(cache));
            } catch (error) {
                console.warn('Unable to persist profile cache', error);
            }
        }

        function readProfileFromCache(userId) {
            const cache = getProfileCache();
            return cache[userId] || null;
        }

        function getProfileCache() {
            try {
                return JSON.parse(localStorage.getItem(PROFILE_CACHE_KEY)) || {};
            } catch (error) {
                return {};
            }
        }

        function sanitizeProfileForCache(profile = {}) {
            return {
                fullName: profile.fullName || '',
                plan: profile.plan || 'Trial',
                status: profile.status || 'trial',
                cancelsAt: serializeTimestamp(profile.cancelsAt),
                renewsAt: serializeTimestamp(profile.renewsAt),
                avatar: profile.avatar || '',
                timeZone: profile.timeZone || '',
                subscriptionId: profile.subscriptionId || profile.stripeSubscriptionId || ''
            };
        }

        function serializeTimestamp(value) {
            if (!value) {
                return null;
            }
            if (typeof value.toDate === 'function') {
                return value.toDate().toISOString();
            }
            if (value instanceof Date) {
                return value.toISOString();
            }
            return value;
        }

        function capitalize(text = '') {
            if (!text) return '';
            return text.charAt(0).toUpperCase() + text.slice(1).toLowerCase();
        }

        function signOut() {
            auth.signOut().then(() => {
                window.location.href = 'index.html';
            }).catch((error) => {
                console.error('Error signing out:', error);
                showToast('Unable to sign out. Please try again.');
            });
        }

        function initUserMenu() {
            if (!userMenuButton || !userDropdown) {
                return;
            }

            userMenuButton.addEventListener('click', (event) => {
                event.stopPropagation();
                toggleUserMenu();
            });

            document.addEventListener('click', (event) => {
                if (!userDropdown.contains(event.target) && !userMenuButton.contains(event.target)) {
                    closeUserMenu();
                }
            });

            document.addEventListener('keydown', (event) => {
                if (event.key === 'Escape') {
                    closeUserMenu();
                }
            });

            userDropdown.querySelectorAll('[data-user-action]').forEach((button) => {
                button.addEventListener('click', () => {
                    handleUserMenuAction(button.dataset.userAction);
                });
            });
        }

        function toggleUserMenu(forceState) {
            if (!userMenuButton || !userDropdown) {
                return;
            }

            const isExpanded = userMenuButton.getAttribute('aria-expanded') === 'true';
            const shouldOpen = typeof forceState === 'boolean' ? forceState : !isExpanded;
            userMenuButton.setAttribute('aria-expanded', String(shouldOpen));
            userDropdown.classList.toggle('open', shouldOpen);
        }

        function closeUserMenu() {
            toggleUserMenu(false);
        }

        function handleUserMenuAction(action) {
            closeUserMenu();
            switch (action) {
                case 'billing':
                    window.location.href = 'billing.html';
                    break;
                case 'settings':
                    window.location.href = 'settings.html';
                    break;
                case 'logout':
                    signOut();
                    break;
                default:
                    break;
            }
        }

        function initTheme() {
            if (!themeToggle) {
                return;
            }

            const storedTheme = localStorage.getItem(THEME_STORAGE_KEY);
            const prefersDark = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches;
            const initialTheme = storedTheme || (prefersDark ? 'dark' : 'light');
            applyTheme(initialTheme);

            themeToggle.addEventListener('click', () => {
                const nextTheme = bodyElement.dataset.theme === 'dark' ? 'light' : 'dark';
                applyTheme(nextTheme);
                localStorage.setItem(THEME_STORAGE_KEY, nextTheme);
            });
        }

        function applyTheme(theme) {
            bodyElement.dataset.theme = theme;

            if (themeToggleIcon) {
                themeToggleIcon.textContent = theme === 'dark' ? 'üåô' : '‚òÄÔ∏è';
            }

            if (themeToggleLabel) {
                themeToggleLabel.textContent = theme === 'dark' ? 'Dark mode' : 'Light mode';
            }

            if (themeToggle) {
                themeToggle.setAttribute('aria-pressed', theme === 'dark');
            }
        }

        const toast = document.getElementById('toast');
        let toastTimeout;
        function showToast(message) {
            toast.textContent = message;
            toast.classList.add('visible');
            clearTimeout(toastTimeout);
            toastTimeout = setTimeout(() => toast.classList.remove('visible'), 3000);
        }
    </script>
</body>
</html>
