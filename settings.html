<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Settings - Lettuce Stream</title>
    <link rel="stylesheet" href="styles.css">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Space+Grotesk:wght@400;500;600;700&family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
</head>
<body class="settings-body">
    <div class="settings-atmosphere"></div>

    <nav class="settings-nav">
        <a href="dashboard.html" class="settings-logo">
            <svg width="34" height="34" viewBox="0 0 32 32" fill="none" xmlns="http://www.w3.org/2000/svg" aria-hidden="true">
                <rect width="32" height="32" rx="8" fill="#F5D547" />
                <path d="M12 9L22 16L12 23V9Z" fill="#0F172A" />
            </svg>
            <span>Lettuce Stream</span>
        </a>
        <div class="settings-nav-actions">
            <a href="billing.html" class="ghost-link">Billing</a>
            <a href="dashboard.html" class="btn-secondary">Back to dashboard</a>
        </div>
    </nav>

    <main class="settings-shell">
        <section class="settings-panel settings-summary" aria-live="polite">
            <div class="summary-head">
                <div class="avatar-preview" id="settingsAvatarPreview" aria-hidden="true">ðŸ‘¤</div>
                <div>
                    <p class="eyebrow">Workspace</p>
                    <h1 id="settingsDisplayName">Loadingâ€¦</h1>
                    <p class="settings-plan" id="settingsPlanBadge">â€”</p>
                    <p class="settings-plan-price" id="settingsPlanPrice">â€”</p>
                    <p class="settings-plan-countdown" id="settingsPlanCountdown" hidden></p>
                </div>
            </div>
            <div class="settings-summary-grid">
                <div>
                    <p class="summary-label">Account email</p>
                    <p class="summary-value" id="settingsEmailPreview">â€”</p>
                </div>
                <div>
                    <p class="summary-label">Time zone</p>
                    <p class="summary-value" id="settingsTimeZonePreview">â€”</p>
                </div>
            </div>
        </section>

        <section class="settings-panel">
            <div class="panel-header">
                <div>
                    <p class="eyebrow">Profile</p>
                    <h2>Personalize how you appear</h2>
                </div>
            </div>
            <form id="profileForm" class="settings-form">
                <label class="field">
                    <span>Full name</span>
                    <input type="text" id="fullName" name="fullName" placeholder="Jamie Producer" autocomplete="name" required>
                </label>

                <label class="field">
                    <span>Time zone</span>
                    <select id="timeZone" name="timeZone">
                        <option value="America/Los_Angeles">Pacific Time (PT)</option>
                        <option value="America/Denver">Mountain Time (MT)</option>
                        <option value="America/Chicago">Central Time (CT)</option>
                        <option value="America/New_York">Eastern Time (ET)</option>
                        <option value="Europe/London">London (GMT)</option>
                        <option value="Europe/Berlin">Central Europe (CET)</option>
                        <option value="Asia/Tokyo">Tokyo (JST)</option>
                        <option value="Australia/Sydney">Sydney (AEST)</option>
                        <option value="UTC">UTC</option>
                    </select>
                </label>

                <div class="avatar-selector">
                    <div class="avatar-selector-head">
                        <p>Profile icon</p>
                        <span>Choose the emoji that represents you across the dashboard.</span>
                    </div>
                    <div class="avatar-options" role="group" aria-label="Profile icon options">
                        <button type="button" class="avatar-choice" data-avatar-option="ðŸŒŠ" aria-pressed="false">ðŸŒŠ</button>
                        <button type="button" class="avatar-choice" data-avatar-option="ðŸŽ§" aria-pressed="false">ðŸŽ§</button>
                        <button type="button" class="avatar-choice" data-avatar-option="ðŸš€" aria-pressed="false">ðŸš€</button>
                        <button type="button" class="avatar-choice" data-avatar-option="ðŸŽ¥" aria-pressed="false">ðŸŽ¥</button>
                        <button type="button" class="avatar-choice" data-avatar-option="ðŸ“¡" aria-pressed="false">ðŸ“¡</button>
                        <button type="button" class="avatar-choice" data-avatar-option="ðŸŒ…" aria-pressed="false">ðŸŒ…</button>
                    </div>
                </div>

                <button type="submit" class="btn-primary settings-submit" id="profileSaveButton">
                    <span>Save profile</span>
                    <span class="button-spinner" aria-hidden="true"></span>
                </button>
            </form>
        </section>

        <section class="settings-panel">
            <div class="panel-header">
                <div>
                    <p class="eyebrow">Account</p>
                    <h2>Update email</h2>
                </div>
                <p class="settings-subtext">You may be asked to sign in again if itâ€™s been a while since your last authentication.</p>
            </div>
            <form id="emailForm" class="settings-form">
                <label class="field">
                    <span>Email address</span>
                    <input type="email" id="emailAddress" name="email" autocomplete="email" required>
                </label>
                <button type="submit" class="btn-secondary settings-submit" id="emailSaveButton">
                    <span>Save email</span>
                    <span class="button-spinner" aria-hidden="true"></span>
                </button>
            </form>
        </section>

        <section class="settings-panel settings-danger">
            <div class="panel-header">
                <div>
                    <p class="eyebrow">Danger zone</p>
                    <h2>Delete account</h2>
                </div>
                <p class="settings-subtext">Deleting will immediately stop your subscription and remove remaining access. This cannot be undone.</p>
            </div>
            <button type="button" class="btn-secondary danger" id="deleteAccount">
                <span>Delete account</span>
            </button>
        </section>
    </main>

    <div class="settings-message" id="settingsMessage" role="status" hidden></div>

    <div class="settings-loading" id="settingsLoading" role="status" aria-live="polite" hidden>
        <div class="loading-indicator"></div>
        <p>Loading your settingsâ€¦</p>
    </div>

    <!-- Firebase -->
    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-auth-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore-compat.js"></script>

    <script src="firebase-config.js"></script>
    <script src="auth-helpers.js"></script>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const PLAN_CATALOG = {
                trial: { label: 'Trial', pricing: { monthly: 'Free during preview' } },
                starter: {
                    label: 'Starter',
                    pricing: {
                        monthly: '$19.99 / month',
                        yearly: '$239.88 / year'
                    }
                },
                pro: {
                    label: 'Pro',
                    pricing: {
                        monthly: '$29.99 / month',
                        yearly: '$359.88 / year'
                    }
                },
                enterprise: {
                    label: 'Enterprise',
                    pricing: {
                        monthly: '$99.99 / month',
                        yearly: '$1199.88 / year'
                    }
                }
            };
            const PAID_STATUS_KEYS = ['active', 'paid', 'upgraded', 'cancelling'];
            const PROFILE_CACHE_KEY = 'lettuce-user-cache';
            const helperFallback = { getErrorMessage: () => 'Unable to complete this action. Please try again.' };
            const { getErrorMessage } = (window.authHelpers || helperFallback);

            const profileForm = document.getElementById('profileForm');
            const emailForm = document.getElementById('emailForm');
            const deleteButton = document.getElementById('deleteAccount');
            const nameInput = document.getElementById('fullName');
            const emailInput = document.getElementById('emailAddress');
            const timeZoneSelect = document.getElementById('timeZone');
            const avatarButtons = document.querySelectorAll('[data-avatar-option]');
            const avatarPreview = document.getElementById('settingsAvatarPreview');
            const displayNameEl = document.getElementById('settingsDisplayName');
            const planBadgeEl = document.getElementById('settingsPlanBadge');
            const planPriceEl = document.getElementById('settingsPlanPrice');
            const planCountdownEl = document.getElementById('settingsPlanCountdown');
            const emailPreviewEl = document.getElementById('settingsEmailPreview');
            const timeZonePreviewEl = document.getElementById('settingsTimeZonePreview');
            const messageEl = document.getElementById('settingsMessage');
            const loadingOverlay = document.getElementById('settingsLoading');

            let activeUser = null;
            let activeProfile = {};
            let selectedAvatar = '';
            let countdownIntervalId = null;

            avatarButtons.forEach((button) => {
                button.addEventListener('click', () => {
                    setAvatarSelection(button.dataset.avatarOption);
                });
            });

            nameInput.addEventListener('input', () => {
                if (!selectedAvatar) {
                    updateAvatarPreview(nameInput.value, '');
                }
            });

            if (typeof auth === 'undefined' || typeof db === 'undefined') {
                showMessage('Firebase failed to load. Please refresh the page.', 'error');
                return;
            }

            auth.onAuthStateChanged(async (user) => {
                if (!user) {
                    window.location.href = 'signin.html?next=settings';
                    return;
                }
                activeUser = user;
                emailPreviewEl.textContent = user.email || 'â€”';
                emailInput.value = user.email || '';
                const renderedFromCache = applyCachedProfile(user);
                await loadProfile({ showSpinner: !renderedFromCache });
            });

            profileForm.addEventListener('submit', async (event) => {
                event.preventDefault();
                if (!activeUser) {
                    return;
                }
                const fullName = nameInput.value.trim();
                const timeZoneValue = timeZoneSelect.value;
                if (!fullName) {
                    showMessage('Please add your name.', 'error');
                    return;
                }
                setButtonLoading(document.getElementById('profileSaveButton'), true);
                try {
                    await db.collection('users').doc(activeUser.uid).set({
                        fullName,
                        timeZone: timeZoneValue,
                        avatar: selectedAvatar || null
                    }, { merge: true });
                    if (activeUser.displayName !== fullName) {
                        await activeUser.updateProfile({ displayName: fullName });
                    }
                    activeProfile = { ...activeProfile, fullName, timeZone: timeZoneValue, avatar: selectedAvatar || '' };
                    refreshSummary();
                    persistProfileCache(activeUser.uid, activeProfile);
                    showMessage('Profile updated.', 'success');
                } catch (error) {
                    console.error('Unable to update profile:', error);
                    showMessage('Unable to update profile. Please try again.', 'error');
                } finally {
                    setButtonLoading(document.getElementById('profileSaveButton'), false);
                }
            });

            emailForm.addEventListener('submit', async (event) => {
                event.preventDefault();
                if (!activeUser) {
                    return;
                }
                const nextEmail = emailInput.value.trim();
                if (!nextEmail || nextEmail === activeUser.email) {
                    showMessage('Your email is already up to date.', 'info');
                    return;
                }
                setButtonLoading(document.getElementById('emailSaveButton'), true);
                try {
                    await activeUser.updateEmail(nextEmail);
                    await db.collection('users').doc(activeUser.uid).set({ email: nextEmail }, { merge: true });
                    emailPreviewEl.textContent = nextEmail;
                    activeProfile = { ...activeProfile, email: nextEmail };
                    persistProfileCache(activeUser.uid, activeProfile);
                    showMessage('Email updated.', 'success');
                } catch (error) {
                    console.error('Unable to update email:', error);
                    const message = error.code === 'auth/requires-recent-login'
                        ? 'Please sign in again to change your email address.'
                        : getErrorMessage(error.code);
                    showMessage(message, 'error');
                } finally {
                    setButtonLoading(document.getElementById('emailSaveButton'), false);
                }
            });

            deleteButton.addEventListener('click', async () => {
                if (!activeUser) {
                    return;
                }
                const confirmation = window.confirm('Delete your account? This immediately cancels your plan and removes access.');
                if (!confirmation) {
                    return;
                }
                setButtonLoading(deleteButton, true);
                try {
                    await cancelStripeSubscriptionIfNeeded();
                    await db.collection('users').doc(activeUser.uid).set({
                        status: 'expired',
                        plan: 'Trial',
                        cancelsAt: firebase.firestore.FieldValue.serverTimestamp(),
                        renewsAt: null,
                        deletedAt: firebase.firestore.FieldValue.serverTimestamp()
                    }, { merge: true });
                    removeProfileCacheEntry(activeUser.uid);
                    await activeUser.delete();
                    showMessage('Account deleted. Thanks for trying Lettuce Stream.', 'success');
                    setTimeout(() => {
                        window.location.href = 'index.html';
                    }, 1200);
                } catch (error) {
                    console.error('Unable to delete account:', error);
                    if (error && error.code === 'auth/requires-recent-login') {
                        showMessage('Please sign in again, then delete your account.', 'error');
                    } else {
                        const friendlyMessage = error?.message || 'Unable to delete your account. Please try again.';
                        showMessage(friendlyMessage, 'error');
                    }
                } finally {
                    setButtonLoading(deleteButton, false);
                }
            });

            async function loadProfile({ showSpinner = true } = {}) {
                if (showSpinner) {
                    setPageLoading(true);
                }
                try {
                    const profileDoc = await db.collection('users').doc(activeUser.uid).get();
                    activeProfile = profileDoc.exists ? profileDoc.data() : {};
                    refreshSummary();
                    persistProfileCache(activeUser.uid, activeProfile);
                } catch (error) {
                    console.error('Unable to load profile:', error);
                    showMessage('Unable to load your profile. Please refresh the page.', 'error');
                } finally {
                    if (showSpinner) {
                        setPageLoading(false);
                    }
                }
            }

            function refreshSummary() {
                const { planKey, billingInterval } = resolvePlanContext(activeProfile);
                const planEntry = PLAN_CATALOG[planKey] || PLAN_CATALOG.trial;
                const status = (activeProfile.status || 'trial').toLowerCase();
                const trialEndsAt = parseTimestamp(activeProfile.trialEndsAt);
                const now = new Date();
                const trialActive = status === 'trial' && trialEndsAt && trialEndsAt > now;
                const trialExpired = status === 'trial' && !trialActive;
                if (trialExpired) {
                    expireTrialAccess(activeUser?.uid);
                }
                const hasPaidSubscription = trialActive || PAID_STATUS_KEYS.includes(status);
                const fullName = activeProfile.fullName || activeUser.displayName || '';
                const email = activeProfile.email || activeUser.email || '';
                displayNameEl.textContent = fullName || email || 'Your workspace';
                nameInput.value = fullName;
                emailInput.value = email;
                const priceLabel = planEntry.pricing?.[billingInterval]
                    || planEntry.pricing?.monthly
                    || planEntry.pricing?.default
                    || '';
                planBadgeEl.textContent = trialActive
                    ? 'Trial access'
                    : (hasPaidSubscription ? `${planEntry.label} plan` : 'Upgrade now');
                planPriceEl.textContent = trialActive
                    ? 'Streaming unlocked during your 24-hour preview.'
                    : hasPaidSubscription
                        ? priceLabel
                        : trialExpired
                            ? 'Trial expired. Upgrade to keep streaming.'
                            : 'Upgrade to unlock multi-streaming.';
                emailPreviewEl.textContent = email || 'â€”';
                const timeZoneValue = activeProfile.timeZone || getBrowserTimeZone();
                syncTimeZoneSelect(timeZoneValue);
                timeZonePreviewEl.textContent = timeZoneValue;
                setAvatarSelection(activeProfile.avatar || '');
                updateAvatarPreview(fullName || email, selectedAvatar);
                if (trialActive) {
                    startPlanCountdown(trialEndsAt);
                } else {
                    stopPlanCountdown({ showExpired: trialExpired });
                }
            }

            function syncTimeZoneSelect(value) {
                if (!value) {
                    return;
                }
                const exists = Array.from(timeZoneSelect.options).some((option) => option.value === value);
                if (!exists) {
                    const customOption = document.createElement('option');
                    customOption.value = value;
                    customOption.textContent = `${value}`;
                    customOption.dataset.dynamic = 'true';
                    timeZoneSelect.appendChild(customOption);
                }
                timeZoneSelect.value = value;
            }

            function setAvatarSelection(choice) {
                selectedAvatar = choice || '';
                avatarButtons.forEach((button) => {
                    const isSelected = button.dataset.avatarOption === selectedAvatar && Boolean(selectedAvatar);
                    button.classList.toggle('selected', isSelected);
                    button.setAttribute('aria-pressed', String(isSelected));
                });
                updateAvatarPreview(nameInput.value || activeUser?.email || '', selectedAvatar);
            }

            function updateAvatarPreview(sourceText, icon) {
                if (!avatarPreview) {
                    return;
                }
                if (icon) {
                    avatarPreview.textContent = icon;
                    avatarPreview.classList.add('avatar-icon');
                } else {
                    const fallback = (sourceText || '').trim().charAt(0).toUpperCase() || 'ðŸ‘¤';
                    avatarPreview.textContent = fallback;
                    avatarPreview.classList.remove('avatar-icon');
                }
            }

            function startPlanCountdown(targetDate) {
                if (!planCountdownEl) {
                    return;
                }
                stopPlanCountdown();
                if (!(targetDate instanceof Date)) {
                    return;
                }
                const render = () => {
                    const remaining = targetDate.getTime() - Date.now();
                    if (remaining <= 0) {
                        stopPlanCountdown({ showExpired: true });
                        return;
                    }
                    planCountdownEl.hidden = false;
                    planCountdownEl.textContent = formatCountdownLabel(remaining);
                };
                render();
                countdownIntervalId = setInterval(render, 1000);
            }

            function stopPlanCountdown({ showExpired = false } = {}) {
                if (countdownIntervalId) {
                    clearInterval(countdownIntervalId);
                    countdownIntervalId = null;
                }
                if (!planCountdownEl) {
                    return;
                }
                if (showExpired) {
                    planCountdownEl.hidden = false;
                    planCountdownEl.textContent = 'Trial expired. Upgrade to keep streaming.';
                } else {
                    planCountdownEl.hidden = true;
                    planCountdownEl.textContent = '';
                }
            }

            function formatCountdownLabel(msRemaining) {
                const totalSeconds = Math.max(0, Math.floor(msRemaining / 1000));
                const hours = Math.floor(totalSeconds / 3600);
                const minutes = Math.floor((totalSeconds % 3600) / 60);
                const seconds = totalSeconds % 60;
                return `Trial access ends in ${padCountdown(hours)}h ${padCountdown(minutes)}m ${padCountdown(seconds)}s`;
            }

            function padCountdown(value) {
                return String(value).padStart(2, '0');
            }

            function showMessage(message, tone = 'info') {
                if (!messageEl) {
                    return;
                }
                if (!message) {
                    messageEl.hidden = true;
                    messageEl.textContent = '';
                    messageEl.dataset.tone = '';
                    return;
                }
                messageEl.hidden = false;
                messageEl.textContent = message;
                messageEl.dataset.tone = tone;
            }

            function setButtonLoading(button, isLoading) {
                if (!button) {
                    return;
                }
                button.disabled = isLoading;
                const spinner = button.querySelector('.button-spinner');
                if (spinner) {
                    spinner.style.opacity = isLoading ? 1 : 0;
                    spinner.style.visibility = isLoading ? 'visible' : 'hidden';
                }
            }

            function setPageLoading(isLoading) {
                if (!loadingOverlay) {
                    return;
                }
                loadingOverlay.hidden = !isLoading;
            }

            function applyCachedProfile(user) {
                const cachedProfile = readProfileFromCache(user.uid);
                if (cachedProfile) {
                    activeProfile = cachedProfile;
                    refreshSummary();
                    return true;
                }
                return false;
            }

            function persistProfileCache(userId, profile) {
                const cache = getProfileCache();
                cache[userId] = sanitizeProfileForCache(profile);
                try {
                    localStorage.setItem(PROFILE_CACHE_KEY, JSON.stringify(cache));
                } catch (error) {
                    console.warn('Unable to persist settings cache', error);
                }
            }

            function removeProfileCacheEntry(userId) {
                const cache = getProfileCache();
                if (cache[userId]) {
                    delete cache[userId];
                    try {
                        localStorage.setItem(PROFILE_CACHE_KEY, JSON.stringify(cache));
                    } catch (error) {
                        console.warn('Unable to clear cached profile', error);
                    }
                }
            }

            async function expireTrialAccess(userId) {
                if (!userId) {
                    return;
                }
                try {
                    await db.collection('users').doc(userId).set({
                        status: 'expired',
                        plan: 'Trial',
                        cancelsAt: null
                    }, { merge: true });
                } catch (error) {
                    console.error('Unable to expire trial access:', error);
                }
            }

            async function cancelStripeSubscriptionIfNeeded() {
                const subscriptionId = resolveSubscriptionId();
                if (!subscriptionId) {
                    return;
                }
                try {
                    const response = await fetch('/api/cancel-subscription', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ subscriptionId })
                    });
                    if (!response.ok) {
                        const payload = await response.json().catch(() => ({}));
                        const message = payload?.error || 'Unable to cancel your subscription right now.';
                        throw new Error(message);
                    }
                } catch (error) {
                    throw new Error(error?.message || 'Unable to cancel your subscription right now.');
                }
            }

            function resolveSubscriptionId() {
                const subscriptionId = activeProfile?.subscriptionId
                    || activeProfile?.stripeSubscriptionId
                    || activeProfile?.subscription?.id
                    || '';
                return typeof subscriptionId === 'string' ? subscriptionId.trim() : '';
            }

            function readProfileFromCache(userId) {
                const cache = getProfileCache();
                return cache[userId] || null;
            }

            function getProfileCache() {
                try {
                    return JSON.parse(localStorage.getItem(PROFILE_CACHE_KEY)) || {};
                } catch (error) {
                    return {};
                }
            }

            function sanitizeProfileForCache(profile = {}) {
                return {
                    fullName: profile.fullName || '',
                    plan: profile.plan || 'Trial',
                    status: profile.status || 'trial',
                    cancelsAt: serializeTimestamp(profile.cancelsAt),
                    renewsAt: serializeTimestamp(profile.renewsAt),
                    avatar: profile.avatar || '',
                    timeZone: profile.timeZone || '',
                    email: profile.email || '',
                    subscriptionId: profile.subscriptionId || profile.stripeSubscriptionId || ''
                };
            }

            function serializeTimestamp(value) {
                if (!value) {
                    return null;
                }
                if (typeof value.toDate === 'function') {
                    return value.toDate().toISOString();
                }
                if (value instanceof Date) {
                    return value.toISOString();
                }
                return value;
            }

            function parseTimestamp(value) {
                if (!value) {
                    return null;
                }
                if (typeof value.toDate === 'function') {
                    return value.toDate();
                }
                const parsed = new Date(value);
                return Number.isNaN(parsed.getTime()) ? null : parsed;
            }

            function getBrowserTimeZone() {
                try {
                    return Intl.DateTimeFormat().resolvedOptions().timeZone;
                } catch (error) {
                    return 'UTC';
                }
            }

            function resolvePlanContext(profile = {}) {
                const rawPlan = (profile.planSlug || profile.plan || 'trial').toString().toLowerCase();
                const normalizedPlan = rawPlan.replace(/[^a-z-]/g, '');
                let basePlan = normalizedPlan.replace(/-(monthly|yearly)$/g, '') || normalizedPlan;
                if (!PLAN_CATALOG[basePlan]) {
                    basePlan = 'trial';
                }
                let billingInterval = (profile.planInterval || profile.billingInterval || profile.subscriptionInterval || '').toString().toLowerCase();
                if (!['monthly', 'yearly'].includes(billingInterval)) {
                    billingInterval = normalizedPlan.includes('year') ? 'yearly' : 'monthly';
                }
                if (basePlan === 'trial') {
                    billingInterval = 'monthly';
                }
                return { planKey: basePlan, billingInterval };
            }
        });
    </script>
</body>
</html>
